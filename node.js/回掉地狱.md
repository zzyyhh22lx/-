# 回调地狱

__callback-hell__



回调函数？

获得异步函数的数据？

```javascript
//callback函数参数是回掉函数来操作异步函数的数据
function fn(callback){
setTimeout(function(){
    var data = 10;
    callback(data);
},1000)
}

fn((data)=>{
    console.log(++data);
})



var fs = require('fs');

fs.readFile('./data.txt', 'utf8', (err, data) => {
    if (err) {
        // 1.如果错误抛出异常，阻止程序运行，把错误打印给服务台
        throw err;
    }
})
```



#### 异步不一定从上往下执行

同步任务作为首要任务会在主线程里执行，异步任务则被“发配”到由另一个线程管理的任务队列中等待处理。异步任务符合条件（比如ajax请求到数据，setTimeout延时到期）后，会在任务队列中添加可执行“事件”，等待主线程中的同步任务执行完毕到任务队列里读取当前可执行的任务，将其加入主线程中执行，以此循环。···



#### 如何保证执行顺序

( 回调地狱 )

```javascript
//嵌套：很丑，无法维护
fs.readFile('data.txt',(err,data)=>{
    fs.readFile('data.txt',(err,data)=>{
    	fs.readFile('data.txt',(err,data)=>{
    
		})
	})
})
```

解决回掉地狱嵌套：



#### `Promise`:(`es6`新增)

- promise 容器，存放一个异步任务
- 等待( pending )==> 成功( resolved )  失败( rejected )
- 不能反复执行
- 是一个构造函数,一旦创建就立即执行

```javascript
// 使用
// 创建一个promise容器
var p = new Promise((resolve, reject) => {
    fs.readFile('data.js', (err, data) => {
        if (err) {
            reject(err);
        } else {
            resolve(data);
        }
    })
});
// resolve(正确)
p.then((data) => {
    // return是给下一个then传递参数
    
    \

}).then((data) => {
    // 如果前面没有传递参数，则是undefined
    console.log(data);
    
}),((err) => {
// reject(错误)
});

// 最后
p.finally(() => {

})
```



#### 重要：

**data.txt和data.txt分别是123和456**

```javascript
var fs = require('fs');
// 创建一个promise容器
var p1 = new Promise((resolve, reject) => {
    fs.readFile('./data.txt', 'utf8', (err, data) => {
        if (err) {
            reject(err);
        } else {
            resolve(data);
        }
    })
});

var p2 = new Promise((resolve, reject) => {
    fs.readFile('./data2.txt', 'utf8', (err, data) => {
        if (err) {
            reject(err);
        } else {
            resolve(data);
        }
    })
})


p1
    .then((data) => {
        console.log(data);
        // return是给下一个then传递参数
        // 如果是 'hello' 或者 123 等 就是 值

        // 这里return 一个promise对象的时候，后续的then方法的第一个参数就会是 p2 的resolve
        return p2;

    })
    .then((data) => 
        console.log(data);
    })
    .catch((err) => {
        console.log(err);
    })
    .finally(() => {
        console.log('结束');
    })
//123 456 结束
```





### 封装

```javascript
var fs = require('fs');

function pReadFile(filePath) {
    return new Promise(function(resolve, reject) {
        fs.readFile(filePath, 'utf8', function(err, data) {
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        })
    })
}


pReadFile('./data.txt')
    .then(function(data) {
        console.log(data);
        return pReadFile('./data2.txt');
    })
    .then(function(data) {
        console.log(data);
    })
    .catch(function(err) {
        console.log(err);
    })
    .catch(function(err) {
        console.log(err);
    })
    .finally(function() {
        console.log('done');
    })

//123 456 done
```

### then-fs使用

```shell
##shell
npm i then-fs
```



```js
//then-fs 是 一个包，跟fs区别是返回一个promise对象
import thenFs from 'then-fs'

thenFs.readFile('./01.txt','utf8').then(r1 => {
    console.log(r1)
    return thenFs.readFile('./01.txt','utf8')
}, err1 =>{
    console.log(err1.message)
}).then(r2 => {
    console.log(r2)
})
```



### async/await

+ aysnc 使得函数值返回一个promise对象

+ await 把返回值为promise对象变成一个值

+ **await必须有aysnc修饰**

+ await代码前是同步执行，后面都是异步执行

  ```js
  async function getAllFile(){
      console.log('a')
      const r1 = await thenFs.readFile('./01.txt','utf8')
      console.log(r1)
      console.log('b')
  }
  
  getAllFile();
  console.log('c')
  
  //输出：(01.txt文件的内容是 txt )
  // a c txt b 
  ```

  

