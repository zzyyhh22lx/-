# 文件操作



- 手动创建目录麻烦

![image-20220430194416176](D:\users\admin\Desktop\学习笔记\node.js\img\15.png)

使用node直接创建目录文件



引用核心模块：

```javascript
const path = reuquire('path');
const fs = reuquire('fs');
```



Node.js中的fs.mkdir()方法用于异步创建目录。

**用法**

```
fs.mkdir(path, mode, callback)
```

**参数：**此方法接受上述和以下所述的三个参数：



- **path:**此参数保存必须创建目录的路径。
- **mode:**此参数保存递归布尔值。 mode选项用于设置目录权限，默认情况下为0777。
- **callback:**此参数保存包含错误的回调函数。如果将递归选项设置为true，则如果要创建的目录已经存在，则不会给出错误消息。

**范例1：**

```
// Node.js program to demonstrate the    
// fs.mkdir() Method 
  
// Include fs and path module 
const fs = require('fs'); 
const path = require('path'); 
   
fs.mkdir(path.join(__dirname, 'test'), (err) => { 
    if (err) { 
        return console.error(err); 
    } 
    console.log('Directory created successfully!'); 
});
```

**输出：**

```
Directory created successfully!
```



![img](https://vimsky.com/wp-content/uploads/2020/02/c2f4a3f3e4b0eda583a8bb4a42931145.jpg)



**注意：**如果您将再次运行该程序，则由于该目录已存在，它将显示一条错误消息。为了克服这个错误，我们将使用递归选项。

**范例2：**此示例说明了递归选项的用法。

```javascript
// Node.js program to demonstrate the    
// fs.mkdir() Method 
  
// Include fs and path module 
const fs = require('fs'); 
const path = require('path'); 
  
fs.mkdir(path.join(__dirname, 'test'), 
  { recursive:true }, (err) => { 
    if (err) { 
      return console.error(err); 
    } 
    console.log('Directory created successfully!'); 
  });
```





#### `path模块`：

```javascript
path.join('','');//拼接目录

path.basename('C:/a/b/index.js');//读出文件名字======>  index.js
path.basename('C:/a/b/index.js','.js');//可以接收俩个参数( 如果后缀名.js一样则输出名字，不一样则全部输出index.js ) ===> index

path.dirname('c:/a/b/index.js');//读出目录===> c:/a/b

path.extname('c:/a/b/index.js');//读出后缀名===> .js

path.isAbsolute('c:/a/b/index.js');//判断是不是绝对路径 ===>true ;  ( 'c/index.js' )==>false

path.parse(url);//封装成一个对象获得其中的数据
```

![image-20220508104044635](D:\users\admin\Desktop\学习笔记\node.js\img\image-20220508104044635.png)

```
// Node.js program to demonstrate the    
// path.join() Method   
  
// Import the path module 
const path = require('path'); 
   
// Joining 2 path-segments 
path1 = path.join("users/admin/files", "index.html"); 
console.log(path1) 
   
// Joining 3 path-segments 
path2 = path.join("users", "geeks/website", "index.html"); 
console.log(path2) 
   
// Joining with zero-length paths 
path3 = path.join("users", "", "", "index.html"); 
console.log(path3)
```

**输出：**

```
users\admin\files\index.html
users\geeks\website\index.html
users\index.html
```



![image-20220501115255189](D:\users\admin\Desktop\学习笔记\node.js\img\16.png)

#### 

#### node中的其他成员

在每个模块中，出来request和exports等相关API外，还有俩个特殊成员

- `__dirname`可以用来获取当前文件模块所属目录的绝对路径//**不包含文件名字** 

​						C:/a/b

- `__filename`可以用来获取当前文件的绝对路径//**包含文件名字**

​						C:/a/b/index.js

- **动态的获取！**

readFile( './index.js',()=>{} )

第一个参数的  ' ./ '  表示在node终端所属的终端路径

![image-20220508105224298](C:\Users\lin\AppData\Roaming\Typora\typora-user-images\image-20220508105224298.png)

尽量用绝对路径，不用相对路径，

读文件操作的时候，移动目录会出现影响

用`__dirname`可以直接动态获得绝对路径，不是写死的，把项目给别人也不会受到影响

用path.join来辅助拼接



![a1261fbbe3204f7d3c216d652801e51](C:\Users\lin\AppData\Local\Temp\WeChat Files\a1261fbbe3204f7d3c216d652801e51.jpg)
